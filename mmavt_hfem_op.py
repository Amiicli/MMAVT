import bpy
import mathutils
from mathutils import Vector

from bpy.types import Operator
from .mmavt_panel import MMAVT_mbody
from .milan_utilities import MUtil
from .MMAVT_property import *


class Milan_OT_Instantiate_HFEM_Properties(Operator):

    bl_idname = "object.instantiate_hfem_properties"
    bl_label = "Add hfem properties"
    bl_description = "Add properties to MMAVT controller bone"
    
    arm_ref : bpy.props.StringProperty(name = "Armature reference", default="")
    hfem_index : bpy.props.IntProperty()

    @classmethod
    def poll(cls, context):
        
        objs = context.view_layer.objects.selected
        ctx = context.mode

        return True
    
    ##TODO: Make it so that people can't name something face in mobdy if they trying to generate an hfem instance
    def execute(cls,context):
        scene = context.scene
        selected_obj = context.selected_objects
        mmavtCtr = bpy.data.objects[cls.arm_ref].pose.bones["MMAVT_Controller"]
        mmavtInst:MMAVT_instance = MUtil.get_mmavt_from_arm_name(cls.arm_ref)
        hfem_list:MMAVT_mbody = mmavtInst.hfem_list

        counter = 0
        for hfem in hfem_list:
            enumPhrase = MUtil.get_HFEM_enum(counter)
            hfem:MMAVT_hfem = hfem
            hfem.name = str(enumPhrase)
            mmavtCtr[enumPhrase] = -1
            mmavtCtr.id_properties_ensure()
            property_manager = mmavtCtr.id_properties_ui(enumPhrase)
            concat = "Autogenerated property " + enumPhrase + " for use in HFEM model swap"
            property_manager.update(min=-1,max=99,soft_min=0,soft_max=99,description=concat)
            counter +=1
        
        mmavtInst.can_use_hfem = True
        return {"FINISHED"}

class Milan_OT_Add_HFEM_Data(Operator):

    bl_idname = "object.add_hfem_data"
    bl_label = "Add hfem data"
    bl_description = "Remove hfem data from hfem group"
    
    arm_ref : bpy.props.StringProperty(name = "Armature reference", default="")
    hfem_index : bpy.props.IntProperty()
    propToAddTo : bpy.props.StringProperty(name = "HFEM to add to", default="")

    @classmethod
    def poll(cls, context):
        objs = context.view_layer.objects.selected
        ctx = context.mode

        if bpy.context.mode == 'OBJECT' or bpy.context.mode == 'POSE':
            return True
        
        return False
    
    def execute(cls,context):
        scene = context.scene
        selected_obj = context.selected_objects
        
        hfem_enum = MUtil.get_HFEM_enum(cls.hfem_index)
        mmavt = MUtil.get_mmavt_from_arm_name(cls.arm_ref)
        hfem_list:MMAVT_mbody = mmavt.hfem_list
        hfem = MUtil.get_hfem_from_list(cls.propToAddTo,hfem_list)
        data:MMAVT_mbody_data = hfem.list.add()
        data.arm:bpy.types.Armature = mmavt.arm
        data.prop_name = cls.propToAddTo
        hfem.foldout = True
        #TODO:ADD OTHER VARIABLES TO FILL IN
        return {"FINISHED"}
    
class Milan_OT_remove_hfem_data(Operator):

    bl_idname = "object.remove_hfem_data"
    bl_label = "Remove obj ref from hfem"
    bl_description = "Remove object from list"

    arm_ref : bpy.props.StringProperty(name = "Armature reference", default="")
    propToRemoveFrom : bpy.props.StringProperty(name = "Property to remove from", default="")
    objToRemove : bpy.props.IntProperty(name="object to remove")
    name : bpy.props.StringProperty(name="name of object to be removed")

    @classmethod
    def poll(cls, context):
        objs = context.view_layer.objects.selected
        ctx = context.mode
        
        return True
    
    def execute(cls,context):
        # test:str = cls.propToAddTo + "/" +
        #  cls.arm_ref
        # print(test)
        mmavt = MUtil.get_mmavt_from_arm_name(cls.arm_ref)   
        props = mmavt.hfem_list
        prop = MUtil.get_hfem_from_list(cls.propToRemoveFrom,props)
        prop.list.remove(cls.objToRemove)
        MUtil.remove_driver(cls.name)
        return {"FINISHED"}

    
def generate_unique_name(nameToUse:str,properties:MMAVT_mbody):
    goofyName = nameToUse + str(1)
    for prop in properties:
        if prop.name == goofyName:
            newName = generate_unique_name(goofyName,properties)
            return newName
    return goofyName
